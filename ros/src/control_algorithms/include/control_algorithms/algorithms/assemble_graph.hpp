// Copyright 2024 Sebastian Theiler
#pragma once

#include <unordered_map>
#include <vector>

#include "control_algorithms/algorithms/common.hpp"

namespace control_algorithms {

using std::vector, std::size_t, std::unordered_map;

enum NodeConnectionType { UNCONNECTED, LEFT, RIGHT, FRONT, BACK };
enum StructureType { WALKER, MOBILE_MANIPULATOR };

using AdjMatrix = vector<vector<NodeConnectionType>>;

// Initialize an empty adjacency matrix of size nxn
AdjMatrix init_adj_matrix(unsigned int n_robots);

// Connect robots in an adj matrix
void connect_robots(AdjMatrix *adj_matrix, unsigned int a, unsigned int b,
                    NodeConnectionType connectionA,
                    NodeConnectionType connectionB);

// Load the specified robots into a given structure
// If no robots are specified, load all robots into that structure
AdjMatrix load_structure(StructureType structure, size_t num_robots);

// Return the height h(v) of a vertex. (the number of the edges of the
// longest downward path to a leaf from v and the height of a rooted graph
// is the height of its root)
// Caches the heights in an unordered_map
int calculate_node_height(const AdjMatrix &adj_matrix, int node,
                          unordered_map<int, int> *heights);

// Returns the cache generated by calculating the height of the root node
unordered_map<int, int> calculate_matrix_heights(const AdjMatrix &adj_matrix,
                                                 int root);

// Recursively calculates the Map location of a node's children (and their
// children)
void calculate_node_children_locations(int node, const Cell &pos,
                                       const AdjMatrix &adj_matrix,
                                       const unordered_map<int, int> &heights,
                                       int radius,
                                       unordered_map<int, Cell> *node_to_pos);

// Converts a structure into a 2D representation with Map locations
// The ith index of the resultant vector has the Map location of robot i
vector<Cell> unfold_graph(const AdjMatrix &adj_matrix, const Cell &root_cell,
                          int root_index, int radius);

// Return the root node of a structure
int get_root_node(AdjMatrix adj_matrix);

}  // namespace control_algorithms
